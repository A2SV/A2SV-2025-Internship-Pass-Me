package repositories_test

import (
	"context"
	"errors" // Import errors for error checking
	"log"
	"os"
	"testing"

	// Adjust import paths as necessary
	domain "github.com/A2SV/A2SV-2025-Internship-Pass-Me/domain"
	repositories "github.com/A2SV/A2SV-2025-Internship-Pass-Me/repositories"

	"github.com/joho/godotenv"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt" // Needed for password hashing simulation
)

// --- Test Suite Setup ---

type UserRepositoryTestSuite struct {
	suite.Suite
	Client     *mongo.Client
	DB         *mongo.Database
	Repo       domain.UserRepository // Use UserRepository interface
	Collection *mongo.Collection     // Specifically the 'users' collection
	ctx        context.Context
}

// SetupSuite runs once before all tests in the suite
func (suite *UserRepositoryTestSuite) SetupSuite() {
	suite.ctx = context.Background()

	// Load .env file specifically for test URI
	if os.Getenv("CI") == "" {
		// Assumes .env is in backend/delivery/ relative to repositories/
		envPath := "../delivery/.env"
		err := godotenv.Load(envPath)
		if err != nil {
			log.Printf("Warning: Could not load .env file from %s: %v", envPath, err)
		} else {
			log.Printf("Loaded environment variables from %s", envPath)
		}
	}

	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		suite.T().Fatal("MONGO_URI_TEST environment variable not set. Skipping integration tests.")
		// Fallback example:
		// mongoURI = "mongodb://localhost:27017/passme_test_db"
		// log.Println("MONGO_URI_TEST not set, falling back to default:", mongoURI)
	}

	clientOpts := options.Client().ApplyURI(mongoURI)
	// Optional: Add timeout settings if needed
	// clientOpts.SetServerSelectionTimeout(5 * time.Second)
	// clientOpts.SetConnectTimeout(5 * time.Second)

	client, err := mongo.Connect(suite.ctx, clientOpts)
	if err != nil {
		suite.T().Fatalf("Failed to connect to MongoDB: %v", err)
	}

	// Ping the database to verify connection early
	err = client.Ping(suite.ctx, nil)
	if err != nil {
		suite.T().Fatalf("Failed to ping MongoDB: %v (URI: %s)", err, mongoURI)
	}

	suite.Client = client

	// Use a dedicated test database name
	suite.DB = suite.Client.Database("passme_test_db") // Ensure consistent test DB name
	suite.Collection = suite.DB.Collection("users")   // Target the 'users' collection
	suite.Repo = repositories.NewUserRepository(suite.DB)

	log.Println("SetupSuite: Connected to test database for user repository tests")
}

// TearDownSuite runs once after all tests in the suite
func (suite *UserRepositoryTestSuite) TearDownSuite() {
	if suite.Client != nil {
		err := suite.Client.Disconnect(suite.ctx)
		if err != nil {
			suite.T().Logf("Error disconnecting from MongoDB: %v", err)
		}
		log.Println("TearDownSuite: Disconnected from test database")
	}
}

// SetupTest runs before each test function
func (suite *UserRepositoryTestSuite) SetupTest() {
	// Clean the 'users' collection before each test
	err := suite.Collection.Drop(suite.ctx)
	if err != nil {
		// Don't fail if collection didn't exist, just log
		log.Printf("Warning: Could not drop 'users' collection before test (might not exist yet): %v\n", err)
	}
	// Optional: Recreate unique indexes if your schema defines them and dropping removes them
	// Example: userIndex := mongo.IndexModel{ Keys: bson.M{"email": 1}, Options: options.Index().SetUnique(true) }
	// _, err = suite.Collection.Indexes().CreateOne(suite.ctx, userIndex)
	// if err != nil { log.Printf("Warning: Could not create index: %v", err) }
}

// Run the Test Suite
func TestUserRepositoryTestSuite(t *testing.T) {
	// This wrapper allows testify/suite to manage setup/teardown
	suite.Run(t, new(UserRepositoryTestSuite))
}

// --- Individual Test Cases ---

func (suite *UserRepositoryTestSuite) TestCreateUser_Success() {
	t := suite.T()
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("password123"), bcrypt.DefaultCost) // Simulate hashing
	testUser := &domain.User{
		// ID will be generated by InsertOne and updated by the repo method
		Username: "testRepoUser",
		Email:    "test.repo@example.com",
		Password: string(hashedPassword),
	}

	// Act
	err := suite.Repo.CreateUser(testUser)

	// Assert repo response
	assert.NoError(t, err)
	assert.NotEqual(t, primitive.NilObjectID, testUser.ID, "User ID should be set after creation")

	// Assert database state
	var createdUser domain.User
	// Use the ID set by CreateUser (which it got from the InsertOne result)
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testUser.ID}).Decode(&createdUser)
	assert.NoError(t, findErr, "Should be able to find the created user in the DB")
	assert.Equal(t, testUser.Username, createdUser.Username)
	assert.Equal(t, testUser.Email, createdUser.Email)
	assert.Equal(t, testUser.Password, createdUser.Password) // Check hashed password persistence
}

// Optional: Test CreateUser duplicate error if you have unique indexes set up
// func (suite *UserRepositoryTestSuite) TestCreateUser_DuplicateEmail() { ... }

func (suite *UserRepositoryTestSuite) TestFindUserByEmail_Found() {
	t := suite.T()
	targetEmail := "find.me@example.com"
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("findPass"), bcrypt.DefaultCost)
	// Arrange: Insert user directly for testing find
	testUser := &domain.User{
		ID:       primitive.NewObjectID(),
		Username: "findMeUser",
		Email:    targetEmail,
		Password: string(hashedPassword),
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testUser)
	assert.NoError(t, err, "Setup: failed to insert user for find by email test")

	// Act
	foundUser, findErr := suite.Repo.FindUserByEmail(targetEmail)

	// Assert
	assert.NoError(t, findErr)
	assert.NotNil(t, foundUser)
	assert.Equal(t, testUser.ID, foundUser.ID)
	assert.Equal(t, testUser.Username, foundUser.Username)
	assert.Equal(t, testUser.Email, foundUser.Email)
}

func (suite *UserRepositoryTestSuite) TestFindUserByEmail_NotFound() {
	t := suite.T()
	nonExistentEmail := "does.not.exist@example.com"

	// Act
	foundUser, findErr := suite.Repo.FindUserByEmail(nonExistentEmail)

	// Assert
	assert.Error(t, findErr)
	assert.Nil(t, foundUser)
	assert.Contains(t, findErr.Error(), "user not found", "Error message should indicate not found")
}

func (suite *UserRepositoryTestSuite) TestFindUserByUsername_Found() {
	t := suite.T()
	targetUsername := "findMeByUsername"
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("findPass"), bcrypt.DefaultCost)
	// Arrange: Insert user
	testUser := &domain.User{
		ID:       primitive.NewObjectID(),
		Username: targetUsername,
		Email:    "find.user@example.com",
		Password: string(hashedPassword),
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testUser)
	assert.NoError(t, err, "Setup: failed to insert user for find by username test")

	// Act
	foundUser, findErr := suite.Repo.FindUserByUsername(targetUsername)

	// Assert
	assert.NoError(t, findErr)
	assert.NotNil(t, foundUser)
	assert.Equal(t, testUser.ID, foundUser.ID)
	assert.Equal(t, testUser.Username, foundUser.Username)
	assert.Equal(t, testUser.Email, foundUser.Email)
}

func (suite *UserRepositoryTestSuite) TestFindUserByUsername_NotFound() {
	t := suite.T()
	nonExistentUsername := "does_not_exist_user"

	// Act
	foundUser, findErr := suite.Repo.FindUserByUsername(nonExistentUsername)

	// Assert
	assert.Error(t, findErr)
	assert.Nil(t, foundUser)
	assert.Contains(t, findErr.Error(), "user not found")
}

func (suite *UserRepositoryTestSuite) TestFindUserByID_Found() {
	t := suite.T()
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("idfindPass"), bcrypt.DefaultCost)
	// Arrange: Insert user
	testUser := &domain.User{
		ID:       primitive.NewObjectID(), // Use generated ID
		Username: "findIDUser",
		Email:    "find.id@example.com",
		Password: string(hashedPassword),
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testUser)
	assert.NoError(t, err, "Setup: failed to insert user for find by ID test")

	// Act
	foundUser, findErr := suite.Repo.FindUserByID(testUser.ID.Hex()) // Use Hex() representation

	// Assert
	assert.NoError(t, findErr)
	assert.NotNil(t, foundUser)
	assert.Equal(t, testUser.ID, foundUser.ID)
	assert.Equal(t, testUser.Username, foundUser.Username)
}

func (suite *UserRepositoryTestSuite) TestFindUserByID_NotFound() {
	t := suite.T()
	nonExistentID := primitive.NewObjectID().Hex() // Valid hex, but not in DB

	// Act
	foundUser, findErr := suite.Repo.FindUserByID(nonExistentID)

	// Assert
	assert.Error(t, findErr) // Expect error from FindOne
	assert.True(t, errors.Is(findErr, mongo.ErrNoDocuments), "Error should be mongo.ErrNoDocuments")
	assert.Nil(t, foundUser)
}

func (suite *UserRepositoryTestSuite) TestFindUserByID_InvalidIDFormat() {
	t := suite.T()
	invalidID := "this-is-not-a-hex-object-id"

	// Act
	foundUser, findErr := suite.Repo.FindUserByID(invalidID)

	// Assert
	assert.Error(t, findErr) // Expect error from primitive.ObjectIDFromHex
	assert.Nil(t, foundUser)
	// Check for the specific error type or message from ObjectIDFromHex
	assert.ErrorContains(t, findErr, "the provided hex string is not a valid ObjectID")
}

func (suite *UserRepositoryTestSuite) TestUpdateUsername_Success() {
	t := suite.T()
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("updateUserPass"), bcrypt.DefaultCost)
	// Arrange: Insert user
	testUser := &domain.User{
		ID:       primitive.NewObjectID(),
		Username: "originalUsername",
		Email:    "update.user@example.com",
		Password: string(hashedPassword),
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testUser)
	assert.NoError(t, err, "Setup: failed to insert user for update username test")

	newUsername := "updatedSuccessfully"

	// Act
	updateErr := suite.Repo.UpdateUsername(testUser.ID.Hex(), newUsername)

	// Assert repo response
	assert.NoError(t, updateErr)

	// Assert database state
	var updatedUser domain.User
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testUser.ID}).Decode(&updatedUser)
	assert.NoError(t, findErr, "Should find user after update")
	assert.Equal(t, newUsername, updatedUser.Username)        // Verify the change
	assert.Equal(t, testUser.Email, updatedUser.Email) // Ensure other fields unchanged
}

func (suite *UserRepositoryTestSuite) TestUpdateUsername_NotFound() {
	t := suite.T()
	nonExistentID := primitive.NewObjectID().Hex()
	newUsername := "updateNonExistent"

	// Act
	updateErr := suite.Repo.UpdateUsername(nonExistentID, newUsername)

	// Assert (UpdateOne doesn't error if filter doesn't match, it just reports MatchedCount=0)
	assert.NoError(t, updateErr)

	// Optional: Verify no document with that ID was created or updated
	count, errDb := suite.Collection.CountDocuments(suite.ctx, bson.M{"_id": nonExistentID})
	assert.NoError(t, errDb)
	assert.Equal(t, int64(0), count, "No user should exist with the non-existent ID")
}

func (suite *UserRepositoryTestSuite) TestUpdateUsername_InvalidIDFormat() {
	t := suite.T()
	invalidID := "bad-id"
	newUsername := "updateBadID"

	// Act
	updateErr := suite.Repo.UpdateUsername(invalidID, newUsername)

	// Assert
	assert.Error(t, updateErr) // Error from primitive.ObjectIDFromHex
	assert.ErrorContains(t, updateErr, "the provided hex string is not a valid ObjectID")
}

func (suite *UserRepositoryTestSuite) TestUpdatePassword_Success() {
	t := suite.T()
	originalHashedPassword, _ := bcrypt.GenerateFromPassword([]byte("originalPass"), bcrypt.DefaultCost)
	// Arrange: Insert user
	testUser := &domain.User{
		ID:       primitive.NewObjectID(),
		Username: "passUpdateUser",
		Email:    "pass.update@example.com",
		Password: string(originalHashedPassword),
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testUser)
	assert.NoError(t, err, "Setup: failed to insert user for password update test")

	newHashedPassword, _ := bcrypt.GenerateFromPassword([]byte("newStrongerPassword"), bcrypt.DefaultCost)

	// Act
	updateErr := suite.Repo.UpdatePassword(testUser.ID.Hex(), string(newHashedPassword))

	// Assert repo response
	assert.NoError(t, updateErr)

	// Assert database state
	var updatedUser domain.User
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testUser.ID}).Decode(&updatedUser)
	assert.NoError(t, findErr, "Should find user after password update")
	assert.Equal(t, string(newHashedPassword), updatedUser.Password) // Verify password changed
	assert.NotEqual(t, string(originalHashedPassword), updatedUser.Password)
	assert.Equal(t, testUser.Username, updatedUser.Username) // Verify other fields
}

func (suite *UserRepositoryTestSuite) TestUpdatePassword_NotFound() {
    t := suite.T()
    nonExistentID := primitive.NewObjectID().Hex()
	newHashedPassword, _ := bcrypt.GenerateFromPassword([]byte("newPassForNonExistent"), bcrypt.DefaultCost)

    // Act
    updateErr := suite.Repo.UpdatePassword(nonExistentID, string(newHashedPassword))

    // Assert (UpdateOne doesn't error if filter doesn't match)
    assert.NoError(t, updateErr)
}


func (suite *UserRepositoryTestSuite) TestUpdatePassword_InvalidIDFormat() {
    t := suite.T()
    invalidID := "bad-pass-id"
	newHashedPassword, _ := bcrypt.GenerateFromPassword([]byte("newPassForBadID"), bcrypt.DefaultCost)

    // Act
    updateErr := suite.Repo.UpdatePassword(invalidID, string(newHashedPassword))

    // Assert
    assert.Error(t, updateErr) // Error from primitive.ObjectIDFromHex
    assert.ErrorContains(t, updateErr, "the provided hex string is not a valid ObjectID")
}