package repositories_test

import (
	"context"
	"log"
	"os"
	"testing"
	"time"

	// Adjust import paths as necessary
	domain "github.com/A2SV/A2SV-2025-Internship-Pass-Me/domain"
	repositories "github.com/A2SV/A2SV-2025-Internship-Pass-Me/repositories"

	"github.com/joho/godotenv"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// --- Test Suite Setup ---

type FlightRepositoryTestSuite struct {
	suite.Suite // Use testify suite for setup/teardown structure
	Client     *mongo.Client
	DB         *mongo.Database
	Repo       domain.FlightRepository
	Collection *mongo.Collection
	ctx        context.Context
}

// SetupSuite runs once before all tests in the suite
func (suite *FlightRepositoryTestSuite) SetupSuite() {
	suite.ctx = context.Background()

	// Load .env file specifically for test URI (optional, adjust path if needed)
	// Assumes .env might be in the root, adjust path if needed
	if os.Getenv("CI") == "" { // Don't load .env in CI if URI is set directly
		err := godotenv.Load("../delivery/.env") // Go up one level from repositories/ to find .env
		if err != nil {
			log.Println("Warning: .env file not found or error loading:", err)
		}
	}


	mongoURI := os.Getenv("MONGO_URI")
	if mongoURI == "" {
		suite.T().Fatal("MONGO_URI_TEST environment variable not set. Skipping integration tests.")
		// Or fallback to a default local URI:
		// mongoURI = "mongodb://localhost:27017/passme_test_db"
		// log.Println("MONGO_URI_TEST not set, falling back to default:", mongoURI)
	}

	client, err := mongo.Connect(suite.ctx, options.Client().ApplyURI(mongoURI))
	if err != nil {
		suite.T().Fatalf("Failed to connect to MongoDB: %v", err)
	}
	suite.Client = client

	// Use a dedicated test database name
	suite.DB = suite.Client.Database("passme_test_db") // Ensure this DB name is different from production
	suite.Collection = suite.DB.Collection("flights")
	suite.Repo = repositories.NewFlightRepository(suite.DB)

	log.Println("SetupSuite: Connected to test database")
}

// TearDownSuite runs once after all tests in the suite
func (suite *FlightRepositoryTestSuite) TearDownSuite() {
	if suite.Client != nil {
		err := suite.Client.Disconnect(suite.ctx)
		if err != nil {
			suite.T().Logf("Error disconnecting from MongoDB: %v", err)
		}
		log.Println("TearDownSuite: Disconnected from test database")
	}
}

// SetupTest runs before each test function
func (suite *FlightRepositoryTestSuite) SetupTest() {
	// Clean the collection before each test for isolation
	err := suite.Collection.Drop(suite.ctx)
	if err != nil {
		// Don't fail if collection didn't exist, just log
		log.Printf("Warning: Could not drop collection before test (might not exist yet): %v\n", err)
	}
	// Optional: Recreate indexes if needed after dropping
	// _, err = suite.Collection.Indexes().CreateOne(...)
}

// TearDownTest runs after each test function (optional)
func (suite *FlightRepositoryTestSuite) TearDownTest() {
	// Add any cleanup needed *after* each specific test if SetupTest isn't sufficient
}

// Run the Test Suite
func TestFlightRepositoryTestSuite(t *testing.T) {
	suite.Run(t, new(FlightRepositoryTestSuite))
}

// --- Individual Test Cases ---

func (suite *FlightRepositoryTestSuite) TestCreateFlight_Success() {
	t := suite.T() // Get the underlying testing.T instance

	testFlight := &domain.Flight{
		// ID will be generated by repo or DB
		Title:       "Integration Test Flight",
		FromCountry: "Testland",
		ToCountry:   "Assertionia",
		Date:        time.Now(),
		UserID:      "user-integration-tester",
		Language:    "GoTest", // Test specific language
		QA: []domain.QA{
			{Question: "Q1?", Answer: "A1."},
			{Question: "Q2?", Answer: "A2."},
			{Question: "Q3?", Answer: "A3."},
			{Question: "Q4?", Answer: "A4."},
			{Question: "Q5?", Answer: "A5."},
		},
	}

	// Act: Call the repository method
	err := suite.Repo.CreateFlight(testFlight)

	// Assert: Check repository response
	assert.NoError(t, err, "CreateFlight should not return an error")
	assert.NotEmpty(t, testFlight.ID, "Flight ID should be set after creation")
	// ID should be a valid hex
	_, hexErr := primitive.ObjectIDFromHex(testFlight.ID)
	assert.NoError(t, hexErr, "Generated ID should be a valid ObjectID hex")


	// Assert: Check database directly
	var createdFlight domain.Flight
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testFlight.ID}).Decode(&createdFlight)
	assert.NoError(t, findErr, "Should be able to find the created flight in the DB")

	// Compare fields (handle time separately due to potential precision differences)
	assert.Equal(t, testFlight.Title, createdFlight.Title)
	assert.Equal(t, testFlight.FromCountry, createdFlight.FromCountry)
	assert.Equal(t, testFlight.ToCountry, createdFlight.ToCountry)
	assert.Equal(t, testFlight.UserID, createdFlight.UserID)
	assert.Equal(t, testFlight.Language, createdFlight.Language)
	assert.Equal(t, testFlight.QA, createdFlight.QA)
	// Compare time with tolerance, ensuring UTC conversion happened
	assert.WithinDuration(t, testFlight.Date.UTC(), createdFlight.Date, time.Second, "Dates should be equal (within tolerance) and UTC")
}

func (suite *FlightRepositoryTestSuite) TestCreateFlight_DefaultLanguage() {
	t := suite.T()
	testFlight := &domain.Flight{
		Title:       "Flight Missing Language",
		FromCountry: "Source",
		ToCountry:   "Destination",
		Date:        time.Now(),
		UserID:      "user-default-lang",
		// Language:    "", // Intentionally omitted
		QA: []domain.QA{ /* ... 5 QA pairs ... */ },
	}

	err := suite.Repo.CreateFlight(testFlight)
	assert.NoError(t, err)
	assert.NotEmpty(t, testFlight.ID)

	// Assert: Check database directly for default language
	var createdFlight domain.Flight
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testFlight.ID}).Decode(&createdFlight)
	assert.NoError(t, findErr)
	assert.Equal(t, "English", createdFlight.Language, "Default language should be set") // Check default
}


func (suite *FlightRepositoryTestSuite) TestGetFlightByID_Found() {
	t := suite.T()
	// Arrange: Insert a flight first
	testFlight := &domain.Flight{
		ID:          primitive.NewObjectID().Hex(), // Predefine ID for easier query
		Title:       "Flight To Get",
		FromCountry: "GetFrom",
		ToCountry:   "GetTo",
		Date:        time.Now().UTC(),
		UserID:      "getter-user",
		Language:    "GetterLang",
		QA:          []domain.QA{/* ... */},
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testFlight)
	assert.NoError(t, err, "Setup: Failed to insert flight for GetByID test")

	// Act: Call the repository method
	foundFlight, getErr := suite.Repo.GetFlightByID(testFlight.ID)

	// Assert
	assert.NoError(t, getErr, "GetFlightByID should not return error for existing ID")
	assert.NotNil(t, foundFlight, "Found flight should not be nil")
	assert.Equal(t, testFlight.ID, foundFlight.ID)
	assert.Equal(t, testFlight.Title, foundFlight.Title)
	assert.Equal(t, testFlight.UserID, foundFlight.UserID)
	assert.WithinDuration(t, testFlight.Date, foundFlight.Date, time.Second)
}

func (suite *FlightRepositoryTestSuite) TestGetFlightByID_NotFound() {
	t := suite.T()
	nonExistentID := primitive.NewObjectID().Hex() // A random, unused ID

	// Act
	foundFlight, getErr := suite.Repo.GetFlightByID(nonExistentID)

	// Assert
	assert.Error(t, getErr, "GetFlightByID should return an error for non-existent ID")
	assert.Nil(t, foundFlight, "Found flight should be nil when not found")
	// Check for the specific error message defined in the repository
	assert.Contains(t, getErr.Error(), "flight not found", "Error message should indicate not found")
}

func (suite *FlightRepositoryTestSuite) TestDeleteFlight_Success() {
	t := suite.T()
	// Arrange: Insert a flight
	testFlight := &domain.Flight{
		ID:          primitive.NewObjectID().Hex(),
		Title:       "Flight To Delete",
		UserID:      "deleter-user",
		Date:        time.Now().UTC(),
		FromCountry: "DeleteFrom",
		ToCountry:   "DeleteTo",
		Language:    "DeleterLang",
		QA:          []domain.QA{/* ... */},
	}
	_, err := suite.Collection.InsertOne(suite.ctx, testFlight)
	assert.NoError(t, err, "Setup: Failed to insert flight for Delete test")

	// Act: Call the repository method
	delErr := suite.Repo.DeleteFlight(testFlight.ID)

	// Assert: Check repository response
	assert.NoError(t, delErr, "DeleteFlight should not return error for existing ID")

	// Assert: Check database directly
	var deletedFlight domain.Flight
	findErr := suite.Collection.FindOne(suite.ctx, bson.M{"_id": testFlight.ID}).Decode(&deletedFlight)
	assert.Error(t, findErr, "Should not find the flight after deletion")
	assert.Equal(t, mongo.ErrNoDocuments, findErr, "Error from FindOne should be ErrNoDocuments")
}

func (suite *FlightRepositoryTestSuite) TestDeleteFlight_NotFound() {
	t := suite.T()
	nonExistentID := primitive.NewObjectID().Hex()

	// Act
	delErr := suite.Repo.DeleteFlight(nonExistentID)

	// Assert
	assert.Error(t, delErr, "DeleteFlight should return an error for non-existent ID")
	assert.Contains(t, delErr.Error(), "flight not found", "Error message should indicate not found")
}


func (suite *FlightRepositoryTestSuite) TestGetFlightsByUserID_FoundMultiple() {
    t := suite.T()
    targetUserID := "user-with-many-flights"
    otherUserID := "user-with-other-flights"

    // Arrange: Insert flights for target user
    flight1 := &domain.Flight{ID: primitive.NewObjectID().Hex(), UserID: targetUserID, Title: "User Flight 1", Date: time.Now().Add(-time.Hour).UTC(), Language: "L1", FromCountry: "F1", ToCountry: "T1", QA: []domain.QA{}}
    flight2 := &domain.Flight{ID: primitive.NewObjectID().Hex(), UserID: targetUserID, Title: "User Flight 2", Date: time.Now().UTC(), Language: "L2", FromCountry: "F2", ToCountry: "T2", QA: []domain.QA{}}
    // Arrange: Insert flight for another user
    flight3 := &domain.Flight{ID: primitive.NewObjectID().Hex(), UserID: otherUserID, Title: "Other User Flight", Date: time.Now().UTC(), Language: "L3", FromCountry: "F3", ToCountry: "T3", QA: []domain.QA{}}

    _, err := suite.Collection.InsertMany(suite.ctx, []interface{}{flight1, flight2, flight3})
    assert.NoError(t, err, "Setup: Failed to insert multiple flights")

    // Act
    foundFlights, getErr := suite.Repo.GetFlightsByUserID(targetUserID)

    // Assert
    assert.NoError(t, getErr, "GetFlightsByUserID should not return error")
    assert.Len(t, foundFlights, 2, "Should find exactly 2 flights for the target user")

    // Check if the correct flights were returned (IDs are sufficient)
    foundIDs := make(map[string]bool)
    for _, f := range foundFlights {
        foundIDs[f.ID] = true
    }
    assert.True(t, foundIDs[flight1.ID], "Flight 1 should be found")
    assert.True(t, foundIDs[flight2.ID], "Flight 2 should be found")
    assert.False(t, foundIDs[flight3.ID], "Flight 3 (other user) should NOT be found")
}


func (suite *FlightRepositoryTestSuite) TestGetFlightsByUserID_NotFound() {
    t := suite.T()
    userIDWithNoFlights := "user-no-flights-yet"

    // Act
    foundFlights, getErr := suite.Repo.GetFlightsByUserID(userIDWithNoFlights)

    // Assert
    assert.NoError(t, getErr, "GetFlightsByUserID should not return error even if no flights found")
    assert.Empty(t, foundFlights, "Should return an empty slice when no flights are found for the user")
    // Or check for nil depending on how you prefer empty results:
    // assert.Nil(t, foundFlights)
}